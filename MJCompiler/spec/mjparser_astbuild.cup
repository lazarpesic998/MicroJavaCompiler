package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}


terminal PROG, BREAK, CLASS, ENUM, ELSE, CONST, IF, DO, WHILE, NEW, PRINT, READ, RETURN, VOID, EXTENDS, CONTINUE, THIS, SUPER, GOTO, RECORD;
terminal PLUS, MINUS, MUL, DIV, MOD, EQ, NEQ, GT, GTE, LT, LTE, AND, OR, EQUAL, INC, DEC, SEMI, COLON, COMMA, DOT, LPAREN, RPAREN, LBRACKET, RBRACKET, LBRACE, RBRACE;

//terminal BOOL;
terminal String BOOL;
terminal Integer NUMBER ;
terminal Character CHAR;
terminal String IDENT ;




nonterminal Unmatched Unmatched;
nonterminal Matched Matched;


nonterminal ConstDecl ConstDecl;
nonterminal Type Type;
nonterminal IdentValuePair IdentValuePair;
nonterminal ConstDeclList ConstDeclList;
nonterminal ConstDeclarations ConstDeclarations ;
nonterminal Variable Variable;
nonterminal VarDeclarations VarDeclarations;
nonterminal VariableList VariableList;
nonterminal Declarations Declarations;
nonterminal VarDeclarationsList VarDeclarationsList;
nonterminal ClassDeclarations ClassDeclarations;
nonterminal Extension Extension;
nonterminal ClassMethodsDeclarations ClassMethodsDeclarations;
nonterminal ConstructorDeclarations ConstructorDeclarations;
nonterminal ConstructorDecl ConstructorDecl;
nonterminal MethDeclarations MethDeclarations;
nonterminal MethDeclarationsOptional MethDeclarationsOptional;
nonterminal RecordDeclarations RecordDeclarations;

nonterminal MethodDecl MethodDecl;
nonterminal MethodType MethodType;
nonterminal MethodDeclList MethodDeclList;
nonterminal FormalParametars FormalParametars;
nonterminal FormPars FormPars;
nonterminal FormParsVariableList FormParsVariableList;
nonterminal Statement Statement;
nonterminal SingleStatement SingleStatement;
nonterminal StatementList StatementList;
nonterminal Label Label;
nonterminal LabelStm LabelStm;
nonterminal Statements Statements;
nonterminal DesignatorStatement DesignatorStatement;
nonterminal Designator Designator;
nonterminal DesignatorOperations DesignatorOperations;
nonterminal DesignatorList DesignatorList;
nonterminal Expr Expr;
nonterminal ExprOptional ExprOptional;
nonterminal MinusPrefix MinusPrefix;
nonterminal CommaNumConstOptional CommaNumConstOptional;
nonterminal Term Term;
nonterminal Factor Factor;

nonterminal ActParsParenOptional ActParsParenOptional;
nonterminal ActParsParen ActParsParen;
nonterminal ActPars ActPars;
nonterminal ActParsList ActParsList;
//operations
nonterminal Assignop Assignop;
nonterminal Relop Relop;
nonterminal Mulop Mulop;
nonterminal MulopFactor MulopFactor;
nonterminal MulopFactorList MulopFactorList;
nonterminal Addop Addop;
nonterminal AddopTerm AddopTerm;
nonterminal AddopTermList AddopTermList;
//condition
nonterminal Condition Condition;
nonterminal CondTerm CondTerm;
nonterminal CondFact CondFact;
nonterminal RelopExpr RelopExpr;
nonterminal AndCondFact AndCondFact;
nonterminal AndCondFactList AndCondFactList;
nonterminal OrCondTerm OrCondTerm;
nonterminal OrCondTermList OrCondTermList;



nonterminal rs.etf.pp1.symboltable.concepts.Obj Program, ProgName, MethodTypeName; 
//nonterminal rs.etf.pp1.symboltable.concepts.Struct VarDeclList; 


precedence left ELSE;

Program ::= (Program) PROG IDENT:progName Declarations:D1 LBRACE MethodDeclList:M2 RBRACE {: RESULT=new Program(progName, D1, M2); RESULT.setLine(progNameleft); :};

Declarations ::= Declarations:D1 ConstDeclarations:C2 {: RESULT=new DeclarationsDerived1(D1, C2); RESULT.setLine(D1left); :}
			 | Declarations:D1 VarDeclarations:V2 {: RESULT=new DeclarationsDerived2(D1, V2); RESULT.setLine(D1left); :}
			 | Declarations:D1 ClassDeclarations:C2 {: RESULT=new DeclarationsDerived3(D1, C2); RESULT.setLine(D1left); :}
			 | Declarations:D1 RecordDeclarations:R2 {: RESULT=new DeclarationsDerived4(D1, R2); RESULT.setLine(D1left); :}
			 | {: RESULT=new DeclarationsDerived5(); :} /*epsilon*/;




							//ConstDecl

ConstDeclarations ::= (ConstDeclarations) CONST Type:constType IdentValuePair:I1 ConstDeclList:C2 SEMI {: RESULT=new ConstDeclarations(constType, I1, C2); RESULT.setLine(constTypeleft); :};

ConstDeclList ::= (ConstDeclLst) ConstDeclList:C1 COMMA IdentValuePair:I2 {: RESULT=new ConstDeclLst(C1, I2); RESULT.setLine(C1left); :}
				| {: RESULT=new ConstDeclListDerived1(); :} /*epsilon*/;



IdentValuePair ::= (NumConst) IDENT:constName EQUAL NUMBER:N1 {: RESULT=new NumConst(constName, N1); RESULT.setLine(constNameleft); :}
				| (BoolConst) IDENT:constName EQUAL BOOL:B1 {: RESULT=new BoolConst(constName, B1); RESULT.setLine(constNameleft); :}
				| (CharConst) IDENT:constName EQUAL CHAR:C1 {: RESULT=new CharConst(constName, C1); RESULT.setLine(constNameleft); :};
				
				


							//VarDecl
						

VarDeclarations ::= (VarDeclarations) Type:varType Variable:V1 VariableList:V2 SEMI {: RESULT=new VarDeclarations(varType, V1, V2); RESULT.setLine(varTypeleft); :};

VariableList ::= (VariableLst) VariableList:V1 COMMA Variable:V2 {: RESULT=new VariableLst(V1, V2); RESULT.setLine(V1left); :}
				| {: RESULT=new VariableListDerived1(); :} /*epsilon*/;


Variable ::= (ArrayVar) IDENT:varName LBRACKET RBRACKET {: RESULT=new ArrayVar(varName); RESULT.setLine(varNameleft); :}
			| (Var) IDENT:varName {: RESULT=new Var(varName); RESULT.setLine(varNameleft); :};
			
VarDeclarationsList ::= (VarDeclarationsLst) VarDeclarationsList:V1 VarDeclarations:V2 {: RESULT=new VarDeclarationsLst(V1, V2); RESULT.setLine(V1left); :}
					| {: RESULT=new VarDeclarationsListDerived1(); :} /*epsilon*/;	


Type ::= (Type) IDENT:I1 {: RESULT=new Type(I1); RESULT.setLine(I1left); :};



							//ClassDecl

ClassDeclarations ::= (ClassDeclarations) CLASS IDENT:className Extension:E1 LBRACE VarDeclarationsList:V2 MethDeclarationsOptional:M3 RBRACE {: RESULT=new ClassDeclarations(className, E1, V2, M3); RESULT.setLine(classNameleft); :};

Extension ::= (Exten) EXTENDS Type:baseClassName {: RESULT=new Exten(baseClassName); RESULT.setLine(baseClassNameleft); :}
			| {: RESULT=new ExtensionDerived1(); :} /*epsilon*/;
			


MethDeclarations ::= (ConstructorMethDeclr) LBRACE MethodDeclList:M1 RBRACE {: RESULT=new ConstructorMethDeclr(M1); RESULT.setLine(M1left); :};

MethDeclarationsOptional ::= (MethDeclarationsOption) MethDeclarations:M1 {: RESULT=new MethDeclarationsOption(M1); RESULT.setLine(M1left); :}
							| {: RESULT=new MethDeclarationsOptionalDerived1(); :} /*epsilon*/;
						
						

						
ConstructorDecl ::= IDENT:constructorName LPAREN RPAREN VarDeclarationsList:V1 LBRACE StatementList:S2 RBRACE {: RESULT=new ConstructorDeclDerived1(constructorName, V1, S2); RESULT.setLine(constructorNameleft); :};

		
							


							//RecordDecl
							
RecordDeclarations ::= (RecordDeclarations) RECORD IDENT:recordName LBRACE VarDeclarationsList:V1 RBRACE {: RESULT=new RecordDeclarations(recordName, V1); RESULT.setLine(recordNameleft); :};


							//Methods
MethodDeclList ::= (MethodDeclLst) MethodDeclList:M1 MethodDecl:M2 {: RESULT=new MethodDeclLst(M1, M2); RESULT.setLine(M1left); :}
				| {: RESULT=new MethodDeclListDerived1(); :} /*epsilon*/;

MethodDecl ::= MethodType:M1 IDENT:methodName LPAREN FormalParametars:F2 RPAREN VarDeclarationsList:V3 LBRACE StatementList:S4 RBRACE {: RESULT=new MethodDeclDerived1(M1, methodName, F2, V3, S4); RESULT.setLine(M1left); :} ;

MethodType ::= Type:T1 {: RESULT=new MethodTypeDerived1(T1); RESULT.setLine(T1left); :} | VOID {: RESULT=new MethodTypeDerived2(); :};

FormalParametars ::= (FormalParms) FormPars:F1 {: RESULT=new FormalParms(F1); RESULT.setLine(F1left); :}
				| {: RESULT=new FormalParametarsDerived1(); :} /*epsilon*/; 

FormPars ::= (FormPars) Type:paramType Variable:V1 FormParsVariableList:F2 {: RESULT=new FormPars(paramType, V1, F2); RESULT.setLine(paramTypeleft); :};

FormParsVariableList ::= (FormParsVariableLst) FormParsVariableList:F1 COMMA Type:T2 Variable:V3 {: RESULT=new FormParsVariableLst(F1, T2, V3); RESULT.setLine(F1left); :}
				| {: RESULT=new FormParsVariableListDerived1(); :} /*epsilon*/;



							//Statements
							
StatementList ::= (StatementLst) StatementList:S1 Statement:S2 {: RESULT=new StatementLst(S1, S2); RESULT.setLine(S1left); :}
				| {: RESULT=new StatementListDerived1(); :} /*epsilon*/;
							
Statement ::= (StmtLabel) Label:L1 COLON SingleStatement:S2 {: RESULT=new StmtLabel(L1, S2); RESULT.setLine(L1left); :}
			| (Stmt) SingleStatement:S1 {: RESULT=new Stmt(S1); RESULT.setLine(S1left); :}
			| (Stmts) Statements:S1 {: RESULT=new Stmts(S1); RESULT.setLine(S1left); :};
			
Statements ::= LBRACE StatementList:S1 RBRACE {: RESULT=new StatementsDerived1(S1); RESULT.setLine(S1left); :};




SingleStatement ::= (DesignatorStm) DesignatorStatement:D1 SEMI {: RESULT=new DesignatorStm(D1); RESULT.setLine(D1left); :}
				| (IfStatement) IF LPAREN Condition:c RPAREN Statement:s {: RESULT=new IfStatement(c, s); RESULT.setLine(cleft); :}
    			| (ElseStatement) IF LPAREN Condition:c RPAREN Statement:s ELSE Statement:e {: RESULT=new ElseStatement(c, s, e); RESULT.setLine(cleft); :}
    			| (DoWhileStatement) DO Statement:S1 WHILE LPAREN Condition:C2 RPAREN SEMI {: RESULT=new DoWhileStatement(S1, C2); RESULT.setLine(S1left); :}
    			| (Break) BREAK SEMI {: RESULT=new Break(); :}
    			| (Continue) CONTINUE SEMI {: RESULT=new Continue(); :}
    			| (ReturnStatement) RETURN ExprOptional:E1 SEMI {: RESULT=new ReturnStatement(E1); RESULT.setLine(E1left); :}
    			| (ReadStatement) READ LPAREN Designator:D1 RPAREN SEMI {: RESULT=new ReadStatement(D1); RESULT.setLine(D1left); :}
    			| (PrintStatement) PRINT LPAREN Expr:E1 CommaNumConstOptional:C2 RPAREN SEMI {: RESULT=new PrintStatement(E1, C2); RESULT.setLine(E1left); :}
    			| (GotoStatement) GOTO Label:L1 SEMI {: RESULT=new GotoStatement(L1); RESULT.setLine(L1left); :};
    			
    			
CommaNumConstOptional ::= (CommaNumConstOption) CommaNumConstOptional:C1 COMMA NUMBER:N2 {: RESULT=new CommaNumConstOption(C1, N2); RESULT.setLine(C1left); :}
						| {: RESULT=new CommaNumConstOptionalDerived1(); :} /*epsilon*/;
    			

Label ::= (Label) IDENT:labelName {: RESULT=new Label(labelName); RESULT.setLine(labelNameleft); :};



							//Condition
							
Condition ::= (Condition) CondTerm:C1 OrCondTermList:O2 {: RESULT=new Condition(C1, O2); RESULT.setLine(C1left); :};

CondTerm ::= (CondTerm) CondFact:C1 AndCondFactList:A2 {: RESULT=new CondTerm(C1, A2); RESULT.setLine(C1left); :};

CondFact ::= (CondFact) Expr:E1 RelopExpr:R2 {: RESULT=new CondFact(E1, R2); RESULT.setLine(E1left); :};

RelopExpr ::= (RelopExprYes) Relop:R1 Expr:E2 {: RESULT=new RelopExprYes(R1, E2); RESULT.setLine(R1left); :}
			| {: RESULT=new RelopExprDerived1(); :} /*epsilon*/;
			
AndCondFact ::= (AndCondFact) AND CondFact:C1 {: RESULT=new AndCondFact(C1); RESULT.setLine(C1left); :};

AndCondFactList ::= (AndCondFactLst) AndCondFactList:A1 AndCondFact:A2 {: RESULT=new AndCondFactLst(A1, A2); RESULT.setLine(A1left); :}
				| {: RESULT=new AndCondFactListDerived1(); :} /*epsilon*/;
				

OrCondTerm ::= (OrCondTerm) OR CondTerm:C1 {: RESULT=new OrCondTerm(C1); RESULT.setLine(C1left); :};

OrCondTermList ::= (OrCondTermLst) OrCondTermList:O1 OrCondTerm:O2 {: RESULT=new OrCondTermLst(O1, O2); RESULT.setLine(O1left); :}
				| {: RESULT=new OrCondTermListDerived1(); :} /*epsilon*/;


							//DesignatorStatement
							
DesignatorStatement ::= (DesignatorStatement) Designator:D1 DesignatorOperations:D2 {: RESULT=new DesignatorStatement(D1, D2); RESULT.setLine(D1left); :};

Designator ::= (Designator) IDENT:designatorName DesignatorList:D1 {: RESULT=new Designator(designatorName, D1); RESULT.setLine(designatorNameleft); :};

DesignatorList ::= (DesignatorClassAndField) DesignatorList:D1 DOT IDENT:I2 {: RESULT=new DesignatorClassAndField(D1, I2); RESULT.setLine(D1left); :}
				| (DesignatorArray) DesignatorList:D1 LBRACKET Expr:E2 RBRACKET {: RESULT=new DesignatorArray(D1, E2); RESULT.setLine(D1left); :}
				| {: RESULT=new DesignatorListDerived1(); :} /*epsilon*/;
			
			
DesignatorOperations ::= (DesignatorAssign) Assignop:A1 Expr:E2 {: RESULT=new DesignatorAssign(A1, E2); RESULT.setLine(A1left); :}
						| (DesignatorParens) ActParsParen:A1 {: RESULT=new DesignatorParens(A1); RESULT.setLine(A1left); :}
						| (DesignatorInc) INC {: RESULT=new DesignatorInc(); :}
						| (DesignatorDec) DEC {: RESULT=new DesignatorDec(); :}
						| {: RESULT=new DesignatorOperationsDerived1(); :} /*epsilon*/;
			
			
Expr ::= (Expr) MinusPrefix:M1 Term:T2 AddopTermList:A3 {: RESULT=new Expr(M1, T2, A3); RESULT.setLine(M1left); :};

ExprOptional ::= (ExprOption) Expr:E1 {: RESULT=new ExprOption(E1); RESULT.setLine(E1left); :}
				| {: RESULT=new ExprOptionalDerived1(); :} /*epsilon*/;

MinusPrefix ::= (MinusPref) MINUS {: RESULT=new MinusPref(); :}
			| {: RESULT=new MinusPrefixDerived1(); :} /*epsilon*/;
			
							 //Term and Factor
			
Term ::= (Term) Factor:F1 MulopFactorList:M2 {: RESULT=new Term(F1, M2); RESULT.setLine(F1left); :};

Factor ::= (DesignatorFactor) Designator:D1 ActParsParenOptional:A2 {: RESULT=new DesignatorFactor(D1, A2); RESULT.setLine(D1left); :}
		| (NumConstFactor) NUMBER:N1 {: RESULT=new NumConstFactor(N1); RESULT.setLine(N1left); :}
		| (CharConstFactor) CHAR:C1 {: RESULT=new CharConstFactor(C1); RESULT.setLine(C1left); :}
		| (BoolConstFactor) BOOL:B1 {: RESULT=new BoolConstFactor(B1); RESULT.setLine(B1left); :}
		| (NewFactor) NEW Type:factorName {: RESULT=new NewFactor(factorName); RESULT.setLine(factorNameleft); :}
		| (NewFactorArray) NEW Type:factorName LBRACKET Expr:E1 RBRACKET {: RESULT=new NewFactorArray(factorName, E1); RESULT.setLine(factorNameleft); :}
		| (ExprFactor) LPAREN Expr:E1 RPAREN {: RESULT=new ExprFactor(E1); RESULT.setLine(E1left); :};
		
		

				 				//ActPars
				 				
				 				
ActPars ::= (ActParams) ActPars:A1 COMMA Expr:E2 {: RESULT=new ActParams(A1, E2); RESULT.setLine(A1left); :} 
		| (ActParam) Expr:E1 {: RESULT=new ActParam(E1); RESULT.setLine(E1left); :};
		
ActParsList ::= (ActParsLst) ActPars:A1 {: RESULT=new ActParsLst(A1); RESULT.setLine(A1left); :}
			| {: RESULT=new ActParsListDerived1(); :} /*epsilon*/;
		
ActParsParen ::= (ActParsParen) LPAREN ActParsList:A1 RPAREN {: RESULT=new ActParsParen(A1); RESULT.setLine(A1left); :};


ActParsParenOptional ::= (ActParsParenYes) ActParsParen:A1 {: RESULT=new ActParsParenYes(A1); RESULT.setLine(A1left); :}
					| {: RESULT=new ActParsParenOptionalDerived1(); :} /*epsilon*/;				



				 				//Operations				 		
		
Assignop ::= (Assignop) EQUAL {: RESULT=new Assignop(); :};

Relop ::= (Eq) EQ {: RESULT=new Eq(); :}
		| (Neq) NEQ {: RESULT=new Neq(); :}
		| (Gt) GT {: RESULT=new Gt(); :}
		| (Gte) GTE {: RESULT=new Gte(); :}
		| (Lt) LT {: RESULT=new Lt(); :}
		| (Lte) LTE {: RESULT=new Lte(); :};
		
		
Mulop ::= (Mul) MUL {: RESULT=new Mul(); :}
		| (Div) DIV {: RESULT=new Div(); :}
		| (Mod) MOD {: RESULT=new Mod(); :};
		
MulopFactor ::= (MulopFactor) Mulop:M1 Factor:F2 {: RESULT=new MulopFactor(M1, F2); RESULT.setLine(M1left); :};

MulopFactorList ::= (MulopFactorLst) MulopFactorList:M1 MulopFactor:M2 {: RESULT=new MulopFactorLst(M1, M2); RESULT.setLine(M1left); :}
				| {: RESULT=new MulopFactorListDerived1(); :} /*epsilon*/;


Addop ::= (Plus) PLUS {: RESULT=new Plus(); :}
		| (Minus) MINUS {: RESULT=new Minus(); :};
		

AddopTerm ::= (AddopTerm) Addop:A1 Term:T2 {: RESULT=new AddopTerm(A1, T2); RESULT.setLine(A1left); :};

AddopTermList ::= (AddopTermLst) AddopTermList:A1 AddopTerm:A2 {: RESULT=new AddopTermLst(A1, A2); RESULT.setLine(A1left); :}
				| {: RESULT=new AddopTermListDerived1(); :} /*epsilon*/;



